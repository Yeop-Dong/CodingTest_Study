tetrominos = [
     # ㅡ, ㅣ
    [[(0,0),(0,1),(0,2),(0,3)], [(0,0),(1,0),(2,0),(3,0)]],
    # ㅁ
    [[(0,0),(0,1),(1,0),(1,1)]],
    # ㄴ 계열 (8개)
    [[(0,0),(1,0),(2,0),(2,1)], [(0,1),(1,1),(2,1),(2,0)],
     [(0,0),(0,1),(1,0),(2,0)], [(0,0),(0,1),(1,1),(2,1)],
     [(0,0),(0,1),(0,2),(1,0)], [(0,0),(0,1),(0,2),(1,2)],
     [(0,2),(1,0),(1,1),(1,2)], [(0,0),(1,0),(1,1),(1,2)]],
    # S, Z 계열 (4개)
    [[(0,0),(0,1),(1,1),(1,2)], [(0,1),(1,0),(1,1),(2,0)],
     [(0,1),(0,2),(1,0),(1,1)], [(0,0),(1,0),(1,1),(2,1)]],
    # ㅗ 계열 (4개)
    [[(0,0),(0,1),(0,2),(1,1)], [(0,1),(1,0),(1,1),(2,1)],
     [(1,0),(1,1),(1,2),(0,1)], [(0,0),(1,0),(1,1),(2,0)]]
]
import sys
input = lambda: sys.stdin.readline().rstrip()
n, m = map(int, input().split())
grid = [list(map(int, input().split())) for _ in range(n)]
res = 0
for y in range(n):
    for x in range(m):
        for t in tetrominos:
            for r in t:
                maxy = y + max(r, key = lambda k: k[0])[0]
                maxx = x + max(r, key = lambda k: k[1])[1]
                if maxy >= n or maxx >= m:
                    continue
                res = max(res, sum([grid[y+i][x+j] for i, j in r]))
print(res)         